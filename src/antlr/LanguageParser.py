# Generated from /Users/spoton/Studia/pg/genetic-programming/src/antlr/Language.g4 by ANTLR 4.13.1
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4,
        1,
        33,
        166,
        2,
        0,
        7,
        0,
        2,
        1,
        7,
        1,
        2,
        2,
        7,
        2,
        2,
        3,
        7,
        3,
        2,
        4,
        7,
        4,
        2,
        5,
        7,
        5,
        2,
        6,
        7,
        6,
        2,
        7,
        7,
        7,
        2,
        8,
        7,
        8,
        2,
        9,
        7,
        9,
        2,
        10,
        7,
        10,
        2,
        11,
        7,
        11,
        2,
        12,
        7,
        12,
        2,
        13,
        7,
        13,
        2,
        14,
        7,
        14,
        2,
        15,
        7,
        15,
        2,
        16,
        7,
        16,
        2,
        17,
        7,
        17,
        2,
        18,
        7,
        18,
        2,
        19,
        7,
        19,
        2,
        20,
        7,
        20,
        2,
        21,
        7,
        21,
        1,
        0,
        3,
        0,
        46,
        8,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        4,
        1,
        51,
        8,
        1,
        11,
        1,
        12,
        1,
        52,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        3,
        2,
        61,
        8,
        2,
        1,
        3,
        1,
        3,
        1,
        3,
        1,
        3,
        1,
        3,
        3,
        3,
        68,
        8,
        3,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        3,
        4,
        75,
        8,
        4,
        1,
        5,
        1,
        5,
        1,
        5,
        1,
        5,
        1,
        6,
        1,
        6,
        3,
        6,
        83,
        8,
        6,
        1,
        6,
        1,
        6,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        3,
        7,
        99,
        8,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        5,
        7,
        121,
        8,
        7,
        10,
        7,
        12,
        7,
        124,
        9,
        7,
        1,
        8,
        1,
        8,
        1,
        9,
        1,
        9,
        1,
        10,
        1,
        10,
        1,
        11,
        1,
        11,
        1,
        12,
        1,
        12,
        1,
        13,
        1,
        13,
        1,
        14,
        1,
        14,
        1,
        15,
        1,
        15,
        3,
        15,
        142,
        8,
        15,
        1,
        16,
        1,
        16,
        1,
        16,
        1,
        17,
        1,
        17,
        1,
        18,
        1,
        18,
        1,
        18,
        1,
        18,
        1,
        18,
        1,
        18,
        1,
        18,
        3,
        18,
        156,
        8,
        18,
        1,
        19,
        1,
        19,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        21,
        1,
        21,
        1,
        21,
        1,
        21,
        0,
        1,
        14,
        22,
        0,
        2,
        4,
        6,
        8,
        10,
        12,
        14,
        16,
        18,
        20,
        22,
        24,
        26,
        28,
        30,
        32,
        34,
        36,
        38,
        40,
        42,
        0,
        5,
        1,
        0,
        6,
        7,
        1,
        0,
        8,
        9,
        1,
        0,
        10,
        12,
        1,
        0,
        25,
        27,
        1,
        0,
        30,
        32,
        164,
        0,
        45,
        1,
        0,
        0,
        0,
        2,
        50,
        1,
        0,
        0,
        0,
        4,
        60,
        1,
        0,
        0,
        0,
        6,
        67,
        1,
        0,
        0,
        0,
        8,
        69,
        1,
        0,
        0,
        0,
        10,
        76,
        1,
        0,
        0,
        0,
        12,
        80,
        1,
        0,
        0,
        0,
        14,
        98,
        1,
        0,
        0,
        0,
        16,
        125,
        1,
        0,
        0,
        0,
        18,
        127,
        1,
        0,
        0,
        0,
        20,
        129,
        1,
        0,
        0,
        0,
        22,
        131,
        1,
        0,
        0,
        0,
        24,
        133,
        1,
        0,
        0,
        0,
        26,
        135,
        1,
        0,
        0,
        0,
        28,
        137,
        1,
        0,
        0,
        0,
        30,
        141,
        1,
        0,
        0,
        0,
        32,
        143,
        1,
        0,
        0,
        0,
        34,
        146,
        1,
        0,
        0,
        0,
        36,
        155,
        1,
        0,
        0,
        0,
        38,
        157,
        1,
        0,
        0,
        0,
        40,
        159,
        1,
        0,
        0,
        0,
        42,
        162,
        1,
        0,
        0,
        0,
        44,
        46,
        3,
        2,
        1,
        0,
        45,
        44,
        1,
        0,
        0,
        0,
        45,
        46,
        1,
        0,
        0,
        0,
        46,
        47,
        1,
        0,
        0,
        0,
        47,
        48,
        5,
        0,
        0,
        1,
        48,
        1,
        1,
        0,
        0,
        0,
        49,
        51,
        3,
        4,
        2,
        0,
        50,
        49,
        1,
        0,
        0,
        0,
        51,
        52,
        1,
        0,
        0,
        0,
        52,
        50,
        1,
        0,
        0,
        0,
        52,
        53,
        1,
        0,
        0,
        0,
        53,
        3,
        1,
        0,
        0,
        0,
        54,
        55,
        3,
        6,
        3,
        0,
        55,
        56,
        5,
        1,
        0,
        0,
        56,
        61,
        1,
        0,
        0,
        0,
        57,
        61,
        3,
        8,
        4,
        0,
        58,
        61,
        3,
        10,
        5,
        0,
        59,
        61,
        3,
        12,
        6,
        0,
        60,
        54,
        1,
        0,
        0,
        0,
        60,
        57,
        1,
        0,
        0,
        0,
        60,
        58,
        1,
        0,
        0,
        0,
        60,
        59,
        1,
        0,
        0,
        0,
        61,
        5,
        1,
        0,
        0,
        0,
        62,
        68,
        3,
        14,
        7,
        0,
        63,
        68,
        3,
        32,
        16,
        0,
        64,
        68,
        3,
        36,
        18,
        0,
        65,
        68,
        3,
        40,
        20,
        0,
        66,
        68,
        3,
        42,
        21,
        0,
        67,
        62,
        1,
        0,
        0,
        0,
        67,
        63,
        1,
        0,
        0,
        0,
        67,
        64,
        1,
        0,
        0,
        0,
        67,
        65,
        1,
        0,
        0,
        0,
        67,
        66,
        1,
        0,
        0,
        0,
        68,
        7,
        1,
        0,
        0,
        0,
        69,
        70,
        5,
        19,
        0,
        0,
        70,
        71,
        3,
        14,
        7,
        0,
        71,
        74,
        3,
        12,
        6,
        0,
        72,
        73,
        5,
        20,
        0,
        0,
        73,
        75,
        3,
        12,
        6,
        0,
        74,
        72,
        1,
        0,
        0,
        0,
        74,
        75,
        1,
        0,
        0,
        0,
        75,
        9,
        1,
        0,
        0,
        0,
        76,
        77,
        5,
        21,
        0,
        0,
        77,
        78,
        3,
        14,
        7,
        0,
        78,
        79,
        3,
        12,
        6,
        0,
        79,
        11,
        1,
        0,
        0,
        0,
        80,
        82,
        5,
        2,
        0,
        0,
        81,
        83,
        3,
        2,
        1,
        0,
        82,
        81,
        1,
        0,
        0,
        0,
        82,
        83,
        1,
        0,
        0,
        0,
        83,
        84,
        1,
        0,
        0,
        0,
        84,
        85,
        5,
        3,
        0,
        0,
        85,
        13,
        1,
        0,
        0,
        0,
        86,
        87,
        6,
        7,
        -1,
        0,
        87,
        88,
        3,
        16,
        8,
        0,
        88,
        89,
        3,
        14,
        7,
        9,
        89,
        99,
        1,
        0,
        0,
        0,
        90,
        91,
        3,
        18,
        9,
        0,
        91,
        92,
        3,
        14,
        7,
        8,
        92,
        99,
        1,
        0,
        0,
        0,
        93,
        94,
        5,
        4,
        0,
        0,
        94,
        95,
        3,
        14,
        7,
        0,
        95,
        96,
        5,
        5,
        0,
        0,
        96,
        99,
        1,
        0,
        0,
        0,
        97,
        99,
        3,
        30,
        15,
        0,
        98,
        86,
        1,
        0,
        0,
        0,
        98,
        90,
        1,
        0,
        0,
        0,
        98,
        93,
        1,
        0,
        0,
        0,
        98,
        97,
        1,
        0,
        0,
        0,
        99,
        122,
        1,
        0,
        0,
        0,
        100,
        101,
        10,
        7,
        0,
        0,
        101,
        102,
        3,
        20,
        10,
        0,
        102,
        103,
        3,
        14,
        7,
        8,
        103,
        121,
        1,
        0,
        0,
        0,
        104,
        105,
        10,
        6,
        0,
        0,
        105,
        106,
        3,
        22,
        11,
        0,
        106,
        107,
        3,
        14,
        7,
        7,
        107,
        121,
        1,
        0,
        0,
        0,
        108,
        109,
        10,
        5,
        0,
        0,
        109,
        110,
        3,
        24,
        12,
        0,
        110,
        111,
        3,
        14,
        7,
        6,
        111,
        121,
        1,
        0,
        0,
        0,
        112,
        113,
        10,
        4,
        0,
        0,
        113,
        114,
        3,
        26,
        13,
        0,
        114,
        115,
        3,
        14,
        7,
        5,
        115,
        121,
        1,
        0,
        0,
        0,
        116,
        117,
        10,
        3,
        0,
        0,
        117,
        118,
        3,
        28,
        14,
        0,
        118,
        119,
        3,
        14,
        7,
        4,
        119,
        121,
        1,
        0,
        0,
        0,
        120,
        100,
        1,
        0,
        0,
        0,
        120,
        104,
        1,
        0,
        0,
        0,
        120,
        108,
        1,
        0,
        0,
        0,
        120,
        112,
        1,
        0,
        0,
        0,
        120,
        116,
        1,
        0,
        0,
        0,
        121,
        124,
        1,
        0,
        0,
        0,
        122,
        120,
        1,
        0,
        0,
        0,
        122,
        123,
        1,
        0,
        0,
        0,
        123,
        15,
        1,
        0,
        0,
        0,
        124,
        122,
        1,
        0,
        0,
        0,
        125,
        126,
        5,
        22,
        0,
        0,
        126,
        17,
        1,
        0,
        0,
        0,
        127,
        128,
        7,
        0,
        0,
        0,
        128,
        19,
        1,
        0,
        0,
        0,
        129,
        130,
        7,
        1,
        0,
        0,
        130,
        21,
        1,
        0,
        0,
        0,
        131,
        132,
        7,
        0,
        0,
        0,
        132,
        23,
        1,
        0,
        0,
        0,
        133,
        134,
        7,
        2,
        0,
        0,
        134,
        25,
        1,
        0,
        0,
        0,
        135,
        136,
        5,
        23,
        0,
        0,
        136,
        27,
        1,
        0,
        0,
        0,
        137,
        138,
        5,
        24,
        0,
        0,
        138,
        29,
        1,
        0,
        0,
        0,
        139,
        142,
        5,
        33,
        0,
        0,
        140,
        142,
        3,
        38,
        19,
        0,
        141,
        139,
        1,
        0,
        0,
        0,
        141,
        140,
        1,
        0,
        0,
        0,
        142,
        31,
        1,
        0,
        0,
        0,
        143,
        144,
        3,
        34,
        17,
        0,
        144,
        145,
        5,
        33,
        0,
        0,
        145,
        33,
        1,
        0,
        0,
        0,
        146,
        147,
        7,
        3,
        0,
        0,
        147,
        35,
        1,
        0,
        0,
        0,
        148,
        149,
        3,
        32,
        16,
        0,
        149,
        150,
        5,
        13,
        0,
        0,
        150,
        151,
        3,
        14,
        7,
        0,
        151,
        156,
        1,
        0,
        0,
        0,
        152,
        153,
        5,
        33,
        0,
        0,
        153,
        154,
        5,
        13,
        0,
        0,
        154,
        156,
        3,
        14,
        7,
        0,
        155,
        148,
        1,
        0,
        0,
        0,
        155,
        152,
        1,
        0,
        0,
        0,
        156,
        37,
        1,
        0,
        0,
        0,
        157,
        158,
        7,
        4,
        0,
        0,
        158,
        39,
        1,
        0,
        0,
        0,
        159,
        160,
        5,
        28,
        0,
        0,
        160,
        161,
        3,
        14,
        7,
        0,
        161,
        41,
        1,
        0,
        0,
        0,
        162,
        163,
        5,
        29,
        0,
        0,
        163,
        164,
        5,
        33,
        0,
        0,
        164,
        43,
        1,
        0,
        0,
        0,
        11,
        45,
        52,
        60,
        67,
        74,
        82,
        98,
        120,
        122,
        141,
        155,
    ]


class LanguageParser(Parser):
    grammarFileName = "Language.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "';'",
        "'{'",
        "'}'",
        "'('",
        "')'",
        "'+'",
        "'-'",
        "'*'",
        "'/'",
        "'>'",
        "'=='",
        "'!='",
        "'='",
        "<INVALID>",
        "'\\t'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'if'",
        "'else'",
        "'while'",
        "'not'",
        "'and'",
        "'or'",
        "'int'",
        "'float'",
        "'bool'",
        "'print'",
        "'read'",
    ]

    symbolicNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "SPACE",
        "TAB",
        "NEWLINE",
        "LINECOMMENT",
        "BLOCKCOMMENT",
        "If",
        "Else",
        "While",
        "Not",
        "And",
        "Or",
        "Int",
        "Float",
        "Bool",
        "Print",
        "Read",
        "BOOLEAN_VAL",
        "FLOAT_VAL",
        "INT_VAL",
        "VARIABLE_NAME",
    ]

    RULE_program = 0
    RULE_statements = 1
    RULE_statement = 2
    RULE_line = 3
    RULE_conditionalStatement = 4
    RULE_loopStatement = 5
    RULE_compoundStatement = 6
    RULE_expression = 7
    RULE_booleanUnaryOperator = 8
    RULE_numericUnaryOperator = 9
    RULE_multiplicationOperator = 10
    RULE_additionOperator = 11
    RULE_comparisonOperator = 12
    RULE_andOperator = 13
    RULE_orOperator = 14
    RULE_atom = 15
    RULE_declaration = 16
    RULE_varType = 17
    RULE_assignment = 18
    RULE_literal = 19
    RULE_printStatement = 20
    RULE_readStatement = 21

    ruleNames = [
        "program",
        "statements",
        "statement",
        "line",
        "conditionalStatement",
        "loopStatement",
        "compoundStatement",
        "expression",
        "booleanUnaryOperator",
        "numericUnaryOperator",
        "multiplicationOperator",
        "additionOperator",
        "comparisonOperator",
        "andOperator",
        "orOperator",
        "atom",
        "declaration",
        "varType",
        "assignment",
        "literal",
        "printStatement",
        "readStatement",
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    SPACE = 14
    TAB = 15
    NEWLINE = 16
    LINECOMMENT = 17
    BLOCKCOMMENT = 18
    If = 19
    Else = 20
    While = 21
    Not = 22
    And = 23
    Or = 24
    Int = 25
    Float = 26
    Bool = 27
    Print = 28
    Read = 29
    BOOLEAN_VAL = 30
    FLOAT_VAL = 31
    INT_VAL = 32
    VARIABLE_NAME = 33

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class ProgramContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(LanguageParser.EOF, 0)

        def statements(self):
            return self.getTypedRuleContext(LanguageParser.StatementsContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_program

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProgram"):
                listener.enterProgram(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProgram"):
                listener.exitProgram(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProgram"):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)

    def program(self):
        localctx = LanguageParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 17153130708) != 0:
                self.state = 44
                self.statements()

            self.state = 47
            self.match(LanguageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.StatementContext)
            else:
                return self.getTypedRuleContext(LanguageParser.StatementContext, i)

        def getRuleIndex(self):
            return LanguageParser.RULE_statements

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatements"):
                listener.enterStatements(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatements"):
                listener.exitStatements(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatements"):
                return visitor.visitStatements(self)
            else:
                return visitor.visitChildren(self)

    def statements(self):
        localctx = LanguageParser.StatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statements)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 49
                self.statement()
                self.state = 52
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3F) == 0 and ((1 << _la) & 17153130708) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def line(self):
            return self.getTypedRuleContext(LanguageParser.LineContext, 0)

        def conditionalStatement(self):
            return self.getTypedRuleContext(LanguageParser.ConditionalStatementContext, 0)

        def loopStatement(self):
            return self.getTypedRuleContext(LanguageParser.LoopStatementContext, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):
        localctx = LanguageParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.state = 60
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 6, 7, 22, 25, 26, 27, 28, 29, 30, 31, 32, 33]:
                self.enterOuterAlt(localctx, 1)
                self.state = 54
                self.line()
                self.state = 55
                self.match(LanguageParser.T__0)
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 57
                self.conditionalStatement()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 58
                self.loopStatement()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 4)
                self.state = 59
                self.compoundStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LineContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def declaration(self):
            return self.getTypedRuleContext(LanguageParser.DeclarationContext, 0)

        def assignment(self):
            return self.getTypedRuleContext(LanguageParser.AssignmentContext, 0)

        def printStatement(self):
            return self.getTypedRuleContext(LanguageParser.PrintStatementContext, 0)

        def readStatement(self):
            return self.getTypedRuleContext(LanguageParser.ReadStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_line

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLine"):
                listener.enterLine(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLine"):
                listener.exitLine(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLine"):
                return visitor.visitLine(self)
            else:
                return visitor.visitChildren(self)

    def line(self):
        localctx = LanguageParser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_line)
        try:
            self.state = 67
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 3, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 62
                self.expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 63
                self.declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 64
                self.assignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 65
                self.printStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 66
                self.readStatement()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(LanguageParser.If, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def compoundStatement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.CompoundStatementContext)
            else:
                return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, i)

        def Else(self):
            return self.getToken(LanguageParser.Else, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_conditionalStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditionalStatement"):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditionalStatement"):
                listener.exitConditionalStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditionalStatement"):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)

    def conditionalStatement(self):
        localctx = LanguageParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditionalStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(LanguageParser.If)
            self.state = 70
            self.expression(0)
            self.state = 71
            self.compoundStatement()
            self.state = 74
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 20:
                self.state = 72
                self.match(LanguageParser.Else)
                self.state = 73
                self.compoundStatement()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LoopStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def While(self):
            return self.getToken(LanguageParser.While, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_loopStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLoopStatement"):
                listener.enterLoopStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLoopStatement"):
                listener.exitLoopStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLoopStatement"):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)

    def loopStatement(self):
        localctx = LanguageParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_loopStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self.match(LanguageParser.While)
            self.state = 77
            self.expression(0)
            self.state = 78
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statements(self):
            return self.getTypedRuleContext(LanguageParser.StatementsContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_compoundStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompoundStatement"):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompoundStatement"):
                listener.exitCompoundStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompoundStatement"):
                return visitor.visitCompoundStatement(self)
            else:
                return visitor.visitChildren(self)

    def compoundStatement(self):
        localctx = LanguageParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_compoundStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(LanguageParser.T__1)
            self.state = 82
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 17153130708) != 0:
                self.state = 81
                self.statements()

            self.state = 84
            self.match(LanguageParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanUnaryOperator(self):
            return self.getTypedRuleContext(LanguageParser.BooleanUnaryOperatorContext, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(LanguageParser.ExpressionContext, i)

        def numericUnaryOperator(self):
            return self.getTypedRuleContext(LanguageParser.NumericUnaryOperatorContext, 0)

        def atom(self):
            return self.getTypedRuleContext(LanguageParser.AtomContext, 0)

        def multiplicationOperator(self):
            return self.getTypedRuleContext(LanguageParser.MultiplicationOperatorContext, 0)

        def additionOperator(self):
            return self.getTypedRuleContext(LanguageParser.AdditionOperatorContext, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(LanguageParser.ComparisonOperatorContext, 0)

        def andOperator(self):
            return self.getTypedRuleContext(LanguageParser.AndOperatorContext, 0)

        def orOperator(self):
            return self.getTypedRuleContext(LanguageParser.OrOperatorContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = LanguageParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22]:
                self.state = 87
                self.booleanUnaryOperator()
                self.state = 88
                self.expression(9)
                pass
            elif token in [6, 7]:
                self.state = 90
                self.numericUnaryOperator()
                self.state = 91
                self.expression(8)
                pass
            elif token in [4]:
                self.state = 93
                self.match(LanguageParser.T__3)
                self.state = 94
                self.expression(0)
                self.state = 95
                self.match(LanguageParser.T__4)
                pass
            elif token in [30, 31, 32, 33]:
                self.state = 97
                self.atom()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 122
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 120
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 7, self._ctx)
                    if la_ == 1:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 100
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 101
                        self.multiplicationOperator()
                        self.state = 102
                        self.expression(8)
                        pass

                    elif la_ == 2:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 104
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 105
                        self.additionOperator()
                        self.state = 106
                        self.expression(7)
                        pass

                    elif la_ == 3:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 108
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 109
                        self.comparisonOperator()
                        self.state = 110
                        self.expression(6)
                        pass

                    elif la_ == 4:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 112
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 113
                        self.andOperator()
                        self.state = 114
                        self.expression(5)
                        pass

                    elif la_ == 5:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 116
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 117
                        self.orOperator()
                        self.state = 118
                        self.expression(4)
                        pass

                self.state = 124
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class BooleanUnaryOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Not(self):
            return self.getToken(LanguageParser.Not, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_booleanUnaryOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBooleanUnaryOperator"):
                listener.enterBooleanUnaryOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBooleanUnaryOperator"):
                listener.exitBooleanUnaryOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBooleanUnaryOperator"):
                return visitor.visitBooleanUnaryOperator(self)
            else:
                return visitor.visitChildren(self)

    def booleanUnaryOperator(self):
        localctx = LanguageParser.BooleanUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_booleanUnaryOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(LanguageParser.Not)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericUnaryOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_numericUnaryOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumericUnaryOperator"):
                listener.enterNumericUnaryOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumericUnaryOperator"):
                listener.exitNumericUnaryOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumericUnaryOperator"):
                return visitor.visitNumericUnaryOperator(self)
            else:
                return visitor.visitChildren(self)

    def numericUnaryOperator(self):
        localctx = LanguageParser.NumericUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_numericUnaryOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            _la = self._input.LA(1)
            if not (_la == 6 or _la == 7):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplicationOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_multiplicationOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplicationOperator"):
                listener.enterMultiplicationOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplicationOperator"):
                listener.exitMultiplicationOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplicationOperator"):
                return visitor.visitMultiplicationOperator(self)
            else:
                return visitor.visitChildren(self)

    def multiplicationOperator(self):
        localctx = LanguageParser.MultiplicationOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_multiplicationOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            _la = self._input.LA(1)
            if not (_la == 8 or _la == 9):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AdditionOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_additionOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditionOperator"):
                listener.enterAdditionOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditionOperator"):
                listener.exitAdditionOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditionOperator"):
                return visitor.visitAdditionOperator(self)
            else:
                return visitor.visitChildren(self)

    def additionOperator(self):
        localctx = LanguageParser.AdditionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_additionOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            _la = self._input.LA(1)
            if not (_la == 6 or _la == 7):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_comparisonOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComparisonOperator"):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComparisonOperator"):
                listener.exitComparisonOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitComparisonOperator"):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)

    def comparisonOperator(self):
        localctx = LanguageParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_comparisonOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3F) == 0 and ((1 << _la) & 7168) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AndOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def And(self):
            return self.getToken(LanguageParser.And, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_andOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAndOperator"):
                listener.enterAndOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAndOperator"):
                listener.exitAndOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAndOperator"):
                return visitor.visitAndOperator(self)
            else:
                return visitor.visitChildren(self)

    def andOperator(self):
        localctx = LanguageParser.AndOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_andOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(LanguageParser.And)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Or(self):
            return self.getToken(LanguageParser.Or, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_orOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrOperator"):
                listener.enterOrOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrOperator"):
                listener.exitOrOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrOperator"):
                return visitor.visitOrOperator(self)
            else:
                return visitor.visitChildren(self)

    def orOperator(self):
        localctx = LanguageParser.OrOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_orOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(LanguageParser.Or)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def literal(self):
            return self.getTypedRuleContext(LanguageParser.LiteralContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_atom

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAtom"):
                listener.enterAtom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAtom"):
                listener.exitAtom(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAtom"):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)

    def atom(self):
        localctx = LanguageParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_atom)
        try:
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [33]:
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.match(LanguageParser.VARIABLE_NAME)
                pass
            elif token in [30, 31, 32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 140
                self.literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varType(self):
            return self.getTypedRuleContext(LanguageParser.VarTypeContext, 0)

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeclaration"):
                listener.enterDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeclaration"):
                listener.exitDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeclaration"):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def declaration(self):
        localctx = LanguageParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.varType()
            self.state = 144
            self.match(LanguageParser.VARIABLE_NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarTypeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Int(self):
            return self.getToken(LanguageParser.Int, 0)

        def Float(self):
            return self.getToken(LanguageParser.Float, 0)

        def Bool(self):
            return self.getToken(LanguageParser.Bool, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_varType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVarType"):
                listener.enterVarType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVarType"):
                listener.exitVarType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVarType"):
                return visitor.visitVarType(self)
            else:
                return visitor.visitChildren(self)

    def varType(self):
        localctx = LanguageParser.VarTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_varType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3F) == 0 and ((1 << _la) & 234881024) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self):
            return self.getTypedRuleContext(LanguageParser.DeclarationContext, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    def assignment(self):
        localctx = LanguageParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_assignment)
        try:
            self.state = 155
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25, 26, 27]:
                self.enterOuterAlt(localctx, 1)
                self.state = 148
                self.declaration()
                self.state = 149
                self.match(LanguageParser.T__12)
                self.state = 150
                self.expression(0)
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 2)
                self.state = 152
                self.match(LanguageParser.VARIABLE_NAME)
                self.state = 153
                self.match(LanguageParser.T__12)
                self.state = 154
                self.expression(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN_VAL(self):
            return self.getToken(LanguageParser.BOOLEAN_VAL, 0)

        def FLOAT_VAL(self):
            return self.getToken(LanguageParser.FLOAT_VAL, 0)

        def INT_VAL(self):
            return self.getToken(LanguageParser.INT_VAL, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):
        localctx = LanguageParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3F) == 0 and ((1 << _la) & 7516192768) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrintStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Print(self):
            return self.getToken(LanguageParser.Print, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_printStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrintStatement"):
                listener.enterPrintStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrintStatement"):
                listener.exitPrintStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrintStatement"):
                return visitor.visitPrintStatement(self)
            else:
                return visitor.visitChildren(self)

    def printStatement(self):
        localctx = LanguageParser.PrintStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_printStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.match(LanguageParser.Print)
            self.state = 160
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReadStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Read(self):
            return self.getToken(LanguageParser.Read, 0)

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_readStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReadStatement"):
                listener.enterReadStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReadStatement"):
                listener.exitReadStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReadStatement"):
                return visitor.visitReadStatement(self)
            else:
                return visitor.visitChildren(self)

    def readStatement(self):
        localctx = LanguageParser.ReadStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_readStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(LanguageParser.Read)
            self.state = 163
            self.match(LanguageParser.VARIABLE_NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[7] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx: ExpressionContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 7)

        if predIndex == 1:
            return self.precpred(self._ctx, 6)

        if predIndex == 2:
            return self.precpred(self._ctx, 5)

        if predIndex == 3:
            return self.precpred(self._ctx, 4)

        if predIndex == 4:
            return self.precpred(self._ctx, 3)
