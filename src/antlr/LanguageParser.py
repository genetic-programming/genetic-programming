# Generated from /Users/spoton/Studia/pg/genetic-programming/src/antlr/Language.g4 by ANTLR 4.13.1
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4,
        1,
        29,
        142,
        2,
        0,
        7,
        0,
        2,
        1,
        7,
        1,
        2,
        2,
        7,
        2,
        2,
        3,
        7,
        3,
        2,
        4,
        7,
        4,
        2,
        5,
        7,
        5,
        2,
        6,
        7,
        6,
        2,
        7,
        7,
        7,
        2,
        8,
        7,
        8,
        2,
        9,
        7,
        9,
        2,
        10,
        7,
        10,
        2,
        11,
        7,
        11,
        2,
        12,
        7,
        12,
        2,
        13,
        7,
        13,
        2,
        14,
        7,
        14,
        2,
        15,
        7,
        15,
        2,
        16,
        7,
        16,
        2,
        17,
        7,
        17,
        2,
        18,
        7,
        18,
        1,
        0,
        5,
        0,
        40,
        8,
        0,
        10,
        0,
        12,
        0,
        43,
        9,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        3,
        1,
        51,
        8,
        1,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        3,
        2,
        57,
        8,
        2,
        1,
        3,
        1,
        3,
        1,
        3,
        1,
        3,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        3,
        4,
        68,
        8,
        4,
        1,
        5,
        1,
        5,
        1,
        5,
        1,
        5,
        1,
        6,
        1,
        6,
        1,
        6,
        1,
        6,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        8,
        1,
        8,
        1,
        8,
        1,
        8,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        3,
        9,
        95,
        8,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        1,
        9,
        5,
        9,
        117,
        8,
        9,
        10,
        9,
        12,
        9,
        120,
        9,
        9,
        1,
        10,
        1,
        10,
        1,
        10,
        1,
        10,
        1,
        11,
        1,
        11,
        1,
        12,
        1,
        12,
        1,
        13,
        1,
        13,
        1,
        14,
        1,
        14,
        1,
        15,
        1,
        15,
        1,
        16,
        1,
        16,
        1,
        17,
        1,
        17,
        1,
        18,
        1,
        18,
        1,
        18,
        0,
        1,
        18,
        19,
        0,
        2,
        4,
        6,
        8,
        10,
        12,
        14,
        16,
        18,
        20,
        22,
        24,
        26,
        28,
        30,
        32,
        34,
        36,
        0,
        4,
        1,
        0,
        27,
        28,
        1,
        0,
        8,
        9,
        2,
        0,
        7,
        7,
        10,
        10,
        1,
        0,
        11,
        13,
        139,
        0,
        41,
        1,
        0,
        0,
        0,
        2,
        50,
        1,
        0,
        0,
        0,
        4,
        56,
        1,
        0,
        0,
        0,
        6,
        58,
        1,
        0,
        0,
        0,
        8,
        62,
        1,
        0,
        0,
        0,
        10,
        69,
        1,
        0,
        0,
        0,
        12,
        73,
        1,
        0,
        0,
        0,
        14,
        77,
        1,
        0,
        0,
        0,
        16,
        80,
        1,
        0,
        0,
        0,
        18,
        94,
        1,
        0,
        0,
        0,
        20,
        121,
        1,
        0,
        0,
        0,
        22,
        125,
        1,
        0,
        0,
        0,
        24,
        127,
        1,
        0,
        0,
        0,
        26,
        129,
        1,
        0,
        0,
        0,
        28,
        131,
        1,
        0,
        0,
        0,
        30,
        133,
        1,
        0,
        0,
        0,
        32,
        135,
        1,
        0,
        0,
        0,
        34,
        137,
        1,
        0,
        0,
        0,
        36,
        139,
        1,
        0,
        0,
        0,
        38,
        40,
        3,
        2,
        1,
        0,
        39,
        38,
        1,
        0,
        0,
        0,
        40,
        43,
        1,
        0,
        0,
        0,
        41,
        39,
        1,
        0,
        0,
        0,
        41,
        42,
        1,
        0,
        0,
        0,
        42,
        1,
        1,
        0,
        0,
        0,
        43,
        41,
        1,
        0,
        0,
        0,
        44,
        45,
        3,
        4,
        2,
        0,
        45,
        46,
        5,
        1,
        0,
        0,
        46,
        51,
        1,
        0,
        0,
        0,
        47,
        51,
        3,
        8,
        4,
        0,
        48,
        51,
        3,
        10,
        5,
        0,
        49,
        51,
        3,
        12,
        6,
        0,
        50,
        44,
        1,
        0,
        0,
        0,
        50,
        47,
        1,
        0,
        0,
        0,
        50,
        48,
        1,
        0,
        0,
        0,
        50,
        49,
        1,
        0,
        0,
        0,
        51,
        3,
        1,
        0,
        0,
        0,
        52,
        57,
        3,
        18,
        9,
        0,
        53,
        57,
        3,
        6,
        3,
        0,
        54,
        57,
        3,
        14,
        7,
        0,
        55,
        57,
        3,
        16,
        8,
        0,
        56,
        52,
        1,
        0,
        0,
        0,
        56,
        53,
        1,
        0,
        0,
        0,
        56,
        54,
        1,
        0,
        0,
        0,
        56,
        55,
        1,
        0,
        0,
        0,
        57,
        5,
        1,
        0,
        0,
        0,
        58,
        59,
        5,
        29,
        0,
        0,
        59,
        60,
        5,
        2,
        0,
        0,
        60,
        61,
        3,
        18,
        9,
        0,
        61,
        7,
        1,
        0,
        0,
        0,
        62,
        63,
        5,
        19,
        0,
        0,
        63,
        64,
        3,
        18,
        9,
        0,
        64,
        67,
        3,
        12,
        6,
        0,
        65,
        66,
        5,
        20,
        0,
        0,
        66,
        68,
        3,
        12,
        6,
        0,
        67,
        65,
        1,
        0,
        0,
        0,
        67,
        68,
        1,
        0,
        0,
        0,
        68,
        9,
        1,
        0,
        0,
        0,
        69,
        70,
        5,
        21,
        0,
        0,
        70,
        71,
        3,
        18,
        9,
        0,
        71,
        72,
        3,
        12,
        6,
        0,
        72,
        11,
        1,
        0,
        0,
        0,
        73,
        74,
        5,
        3,
        0,
        0,
        74,
        75,
        3,
        0,
        0,
        0,
        75,
        76,
        5,
        4,
        0,
        0,
        76,
        13,
        1,
        0,
        0,
        0,
        77,
        78,
        5,
        25,
        0,
        0,
        78,
        79,
        3,
        18,
        9,
        0,
        79,
        15,
        1,
        0,
        0,
        0,
        80,
        81,
        5,
        26,
        0,
        0,
        81,
        82,
        5,
        29,
        0,
        0,
        82,
        83,
        3,
        18,
        9,
        0,
        83,
        17,
        1,
        0,
        0,
        0,
        84,
        85,
        6,
        9,
        -1,
        0,
        85,
        86,
        3,
        24,
        12,
        0,
        86,
        87,
        3,
        18,
        9,
        10,
        87,
        95,
        1,
        0,
        0,
        0,
        88,
        89,
        3,
        26,
        13,
        0,
        89,
        90,
        3,
        18,
        9,
        9,
        90,
        95,
        1,
        0,
        0,
        0,
        91,
        95,
        3,
        20,
        10,
        0,
        92,
        95,
        5,
        29,
        0,
        0,
        93,
        95,
        3,
        22,
        11,
        0,
        94,
        84,
        1,
        0,
        0,
        0,
        94,
        88,
        1,
        0,
        0,
        0,
        94,
        91,
        1,
        0,
        0,
        0,
        94,
        92,
        1,
        0,
        0,
        0,
        94,
        93,
        1,
        0,
        0,
        0,
        95,
        118,
        1,
        0,
        0,
        0,
        96,
        97,
        10,
        8,
        0,
        0,
        97,
        98,
        3,
        28,
        14,
        0,
        98,
        99,
        3,
        18,
        9,
        9,
        99,
        117,
        1,
        0,
        0,
        0,
        100,
        101,
        10,
        7,
        0,
        0,
        101,
        102,
        3,
        30,
        15,
        0,
        102,
        103,
        3,
        18,
        9,
        8,
        103,
        117,
        1,
        0,
        0,
        0,
        104,
        105,
        10,
        6,
        0,
        0,
        105,
        106,
        3,
        32,
        16,
        0,
        106,
        107,
        3,
        18,
        9,
        7,
        107,
        117,
        1,
        0,
        0,
        0,
        108,
        109,
        10,
        5,
        0,
        0,
        109,
        110,
        3,
        34,
        17,
        0,
        110,
        111,
        3,
        18,
        9,
        6,
        111,
        117,
        1,
        0,
        0,
        0,
        112,
        113,
        10,
        4,
        0,
        0,
        113,
        114,
        3,
        36,
        18,
        0,
        114,
        115,
        3,
        18,
        9,
        5,
        115,
        117,
        1,
        0,
        0,
        0,
        116,
        96,
        1,
        0,
        0,
        0,
        116,
        100,
        1,
        0,
        0,
        0,
        116,
        104,
        1,
        0,
        0,
        0,
        116,
        108,
        1,
        0,
        0,
        0,
        116,
        112,
        1,
        0,
        0,
        0,
        117,
        120,
        1,
        0,
        0,
        0,
        118,
        116,
        1,
        0,
        0,
        0,
        118,
        119,
        1,
        0,
        0,
        0,
        119,
        19,
        1,
        0,
        0,
        0,
        120,
        118,
        1,
        0,
        0,
        0,
        121,
        122,
        5,
        5,
        0,
        0,
        122,
        123,
        3,
        18,
        9,
        0,
        123,
        124,
        5,
        6,
        0,
        0,
        124,
        21,
        1,
        0,
        0,
        0,
        125,
        126,
        7,
        0,
        0,
        0,
        126,
        23,
        1,
        0,
        0,
        0,
        127,
        128,
        5,
        22,
        0,
        0,
        128,
        25,
        1,
        0,
        0,
        0,
        129,
        130,
        5,
        7,
        0,
        0,
        130,
        27,
        1,
        0,
        0,
        0,
        131,
        132,
        7,
        1,
        0,
        0,
        132,
        29,
        1,
        0,
        0,
        0,
        133,
        134,
        7,
        2,
        0,
        0,
        134,
        31,
        1,
        0,
        0,
        0,
        135,
        136,
        7,
        3,
        0,
        0,
        136,
        33,
        1,
        0,
        0,
        0,
        137,
        138,
        5,
        23,
        0,
        0,
        138,
        35,
        1,
        0,
        0,
        0,
        139,
        140,
        5,
        24,
        0,
        0,
        140,
        37,
        1,
        0,
        0,
        0,
        7,
        41,
        50,
        56,
        67,
        94,
        116,
        118,
    ]


class LanguageParser(Parser):
    grammarFileName = "Language.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "';'",
        "'='",
        "'{'",
        "'}'",
        "'('",
        "')'",
        "'-'",
        "'*'",
        "'/'",
        "'+'",
        "'>'",
        "'=='",
        "'!='",
        "<INVALID>",
        "'\\t'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'if'",
        "'else'",
        "'while'",
        "'not'",
        "'and'",
        "'or'",
        "'print'",
        "'read'",
    ]

    symbolicNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "SPACE",
        "TAB",
        "NEWLINE",
        "LINECOMMENT",
        "BLOCKCOMMENT",
        "If",
        "Else",
        "While",
        "Not",
        "And",
        "Or",
        "Print",
        "Read",
        "BOOLEAN_VAL",
        "INT_VAL",
        "VARIABLE_NAME",
    ]

    RULE_statements = 0
    RULE_statement = 1
    RULE_line = 2
    RULE_assignment = 3
    RULE_conditionalStatement = 4
    RULE_loopStatement = 5
    RULE_compoundStatement = 6
    RULE_printStatement = 7
    RULE_readStatement = 8
    RULE_expression = 9
    RULE_nestedExpression = 10
    RULE_literal = 11
    RULE_booleanUnaryOperator = 12
    RULE_numericUnaryOperator = 13
    RULE_multiplicationOperator = 14
    RULE_additionOperator = 15
    RULE_comparisonOperator = 16
    RULE_andOperator = 17
    RULE_orOperator = 18

    ruleNames = [
        "statements",
        "statement",
        "line",
        "assignment",
        "conditionalStatement",
        "loopStatement",
        "compoundStatement",
        "printStatement",
        "readStatement",
        "expression",
        "nestedExpression",
        "literal",
        "booleanUnaryOperator",
        "numericUnaryOperator",
        "multiplicationOperator",
        "additionOperator",
        "comparisonOperator",
        "andOperator",
        "orOperator",
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    SPACE = 14
    TAB = 15
    NEWLINE = 16
    LINECOMMENT = 17
    BLOCKCOMMENT = 18
    If = 19
    Else = 20
    While = 21
    Not = 22
    And = 23
    Or = 24
    Print = 25
    Read = 26
    BOOLEAN_VAL = 27
    INT_VAL = 28
    VARIABLE_NAME = 29

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class StatementsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.StatementContext)
            else:
                return self.getTypedRuleContext(LanguageParser.StatementContext, i)

        def getRuleIndex(self):
            return LanguageParser.RULE_statements

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatements"):
                listener.enterStatements(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatements"):
                listener.exitStatements(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatements"):
                return visitor.visitStatements(self)
            else:
                return visitor.visitChildren(self)

    def statements(self):
        localctx = LanguageParser.StatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_statements)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3F) == 0 and ((1 << _la) & 1047003304) != 0:
                self.state = 38
                self.statement()
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def line(self):
            return self.getTypedRuleContext(LanguageParser.LineContext, 0)

        def conditionalStatement(self):
            return self.getTypedRuleContext(LanguageParser.ConditionalStatementContext, 0)

        def loopStatement(self):
            return self.getTypedRuleContext(LanguageParser.LoopStatementContext, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):
        localctx = LanguageParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 50
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 7, 22, 25, 26, 27, 28, 29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.line()
                self.state = 45
                self.match(LanguageParser.T__0)
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 47
                self.conditionalStatement()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 48
                self.loopStatement()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 49
                self.compoundStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LineContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def assignment(self):
            return self.getTypedRuleContext(LanguageParser.AssignmentContext, 0)

        def printStatement(self):
            return self.getTypedRuleContext(LanguageParser.PrintStatementContext, 0)

        def readStatement(self):
            return self.getTypedRuleContext(LanguageParser.ReadStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_line

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLine"):
                listener.enterLine(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLine"):
                listener.exitLine(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLine"):
                return visitor.visitLine(self)
            else:
                return visitor.visitChildren(self)

    def line(self):
        localctx = LanguageParser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_line)
        try:
            self.state = 56
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 2, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 52
                self.expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.assignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 54
                self.printStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 55
                self.readStatement()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    def assignment(self):
        localctx = LanguageParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(LanguageParser.VARIABLE_NAME)
            self.state = 59
            self.match(LanguageParser.T__1)
            self.state = 60
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(LanguageParser.If, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def compoundStatement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.CompoundStatementContext)
            else:
                return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, i)

        def Else(self):
            return self.getToken(LanguageParser.Else, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_conditionalStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditionalStatement"):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditionalStatement"):
                listener.exitConditionalStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditionalStatement"):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)

    def conditionalStatement(self):
        localctx = LanguageParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditionalStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(LanguageParser.If)
            self.state = 63
            self.expression(0)
            self.state = 64
            self.compoundStatement()
            self.state = 67
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 20:
                self.state = 65
                self.match(LanguageParser.Else)
                self.state = 66
                self.compoundStatement()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LoopStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def While(self):
            return self.getToken(LanguageParser.While, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(LanguageParser.CompoundStatementContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_loopStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLoopStatement"):
                listener.enterLoopStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLoopStatement"):
                listener.exitLoopStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLoopStatement"):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)

    def loopStatement(self):
        localctx = LanguageParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_loopStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(LanguageParser.While)
            self.state = 70
            self.expression(0)
            self.state = 71
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statements(self):
            return self.getTypedRuleContext(LanguageParser.StatementsContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_compoundStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompoundStatement"):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompoundStatement"):
                listener.exitCompoundStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompoundStatement"):
                return visitor.visitCompoundStatement(self)
            else:
                return visitor.visitChildren(self)

    def compoundStatement(self):
        localctx = LanguageParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_compoundStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.match(LanguageParser.T__2)
            self.state = 74
            self.statements()
            self.state = 75
            self.match(LanguageParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrintStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Print(self):
            return self.getToken(LanguageParser.Print, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_printStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrintStatement"):
                listener.enterPrintStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrintStatement"):
                listener.exitPrintStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrintStatement"):
                return visitor.visitPrintStatement(self)
            else:
                return visitor.visitChildren(self)

    def printStatement(self):
        localctx = LanguageParser.PrintStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_printStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(LanguageParser.Print)
            self.state = 78
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReadStatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Read(self):
            return self.getToken(LanguageParser.Read, 0)

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_readStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReadStatement"):
                listener.enterReadStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReadStatement"):
                listener.exitReadStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReadStatement"):
                return visitor.visitReadStatement(self)
            else:
                return visitor.visitChildren(self)

    def readStatement(self):
        localctx = LanguageParser.ReadStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_readStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(LanguageParser.Read)
            self.state = 81
            self.match(LanguageParser.VARIABLE_NAME)
            self.state = 82
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanUnaryOperator(self):
            return self.getTypedRuleContext(LanguageParser.BooleanUnaryOperatorContext, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(LanguageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(LanguageParser.ExpressionContext, i)

        def numericUnaryOperator(self):
            return self.getTypedRuleContext(LanguageParser.NumericUnaryOperatorContext, 0)

        def nestedExpression(self):
            return self.getTypedRuleContext(LanguageParser.NestedExpressionContext, 0)

        def VARIABLE_NAME(self):
            return self.getToken(LanguageParser.VARIABLE_NAME, 0)

        def literal(self):
            return self.getTypedRuleContext(LanguageParser.LiteralContext, 0)

        def multiplicationOperator(self):
            return self.getTypedRuleContext(LanguageParser.MultiplicationOperatorContext, 0)

        def additionOperator(self):
            return self.getTypedRuleContext(LanguageParser.AdditionOperatorContext, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(LanguageParser.ComparisonOperatorContext, 0)

        def andOperator(self):
            return self.getTypedRuleContext(LanguageParser.AndOperatorContext, 0)

        def orOperator(self):
            return self.getTypedRuleContext(LanguageParser.OrOperatorContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = LanguageParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 18
        self.enterRecursionRule(localctx, 18, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22]:
                self.state = 85
                self.booleanUnaryOperator()
                self.state = 86
                self.expression(10)
                pass
            elif token in [7]:
                self.state = 88
                self.numericUnaryOperator()
                self.state = 89
                self.expression(9)
                pass
            elif token in [5]:
                self.state = 91
                self.nestedExpression()
                pass
            elif token in [29]:
                self.state = 92
                self.match(LanguageParser.VARIABLE_NAME)
                pass
            elif token in [27, 28]:
                self.state = 93
                self.literal()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 118
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 6, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 116
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
                    if la_ == 1:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 96
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 97
                        self.multiplicationOperator()
                        self.state = 98
                        self.expression(9)
                        pass

                    elif la_ == 2:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 100
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 101
                        self.additionOperator()
                        self.state = 102
                        self.expression(8)
                        pass

                    elif la_ == 3:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 104
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 105
                        self.comparisonOperator()
                        self.state = 106
                        self.expression(7)
                        pass

                    elif la_ == 4:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 108
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 109
                        self.andOperator()
                        self.state = 110
                        self.expression(6)
                        pass

                    elif la_ == 5:
                        localctx = LanguageParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 112
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 113
                        self.orOperator()
                        self.state = 114
                        self.expression(5)
                        pass

                self.state = 120
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 6, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class NestedExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(LanguageParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_nestedExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNestedExpression"):
                listener.enterNestedExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNestedExpression"):
                listener.exitNestedExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNestedExpression"):
                return visitor.visitNestedExpression(self)
            else:
                return visitor.visitChildren(self)

    def nestedExpression(self):
        localctx = LanguageParser.NestedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_nestedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(LanguageParser.T__4)
            self.state = 122
            self.expression(0)
            self.state = 123
            self.match(LanguageParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN_VAL(self):
            return self.getToken(LanguageParser.BOOLEAN_VAL, 0)

        def INT_VAL(self):
            return self.getToken(LanguageParser.INT_VAL, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):
        localctx = LanguageParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not (_la == 27 or _la == 28):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanUnaryOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Not(self):
            return self.getToken(LanguageParser.Not, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_booleanUnaryOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBooleanUnaryOperator"):
                listener.enterBooleanUnaryOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBooleanUnaryOperator"):
                listener.exitBooleanUnaryOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBooleanUnaryOperator"):
                return visitor.visitBooleanUnaryOperator(self)
            else:
                return visitor.visitChildren(self)

    def booleanUnaryOperator(self):
        localctx = LanguageParser.BooleanUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_booleanUnaryOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(LanguageParser.Not)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericUnaryOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_numericUnaryOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumericUnaryOperator"):
                listener.enterNumericUnaryOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumericUnaryOperator"):
                listener.exitNumericUnaryOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumericUnaryOperator"):
                return visitor.visitNumericUnaryOperator(self)
            else:
                return visitor.visitChildren(self)

    def numericUnaryOperator(self):
        localctx = LanguageParser.NumericUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_numericUnaryOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(LanguageParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplicationOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_multiplicationOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplicationOperator"):
                listener.enterMultiplicationOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplicationOperator"):
                listener.exitMultiplicationOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplicationOperator"):
                return visitor.visitMultiplicationOperator(self)
            else:
                return visitor.visitChildren(self)

    def multiplicationOperator(self):
        localctx = LanguageParser.MultiplicationOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_multiplicationOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            _la = self._input.LA(1)
            if not (_la == 8 or _la == 9):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AdditionOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_additionOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditionOperator"):
                listener.enterAdditionOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditionOperator"):
                listener.exitAdditionOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditionOperator"):
                return visitor.visitAdditionOperator(self)
            else:
                return visitor.visitChildren(self)

    def additionOperator(self):
        localctx = LanguageParser.AdditionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_additionOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            _la = self._input.LA(1)
            if not (_la == 7 or _la == 10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return LanguageParser.RULE_comparisonOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterComparisonOperator"):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitComparisonOperator"):
                listener.exitComparisonOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitComparisonOperator"):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)

    def comparisonOperator(self):
        localctx = LanguageParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_comparisonOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3F) == 0 and ((1 << _la) & 14336) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AndOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def And(self):
            return self.getToken(LanguageParser.And, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_andOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAndOperator"):
                listener.enterAndOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAndOperator"):
                listener.exitAndOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAndOperator"):
                return visitor.visitAndOperator(self)
            else:
                return visitor.visitChildren(self)

    def andOperator(self):
        localctx = LanguageParser.AndOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_andOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(LanguageParser.And)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrOperatorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Or(self):
            return self.getToken(LanguageParser.Or, 0)

        def getRuleIndex(self):
            return LanguageParser.RULE_orOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrOperator"):
                listener.enterOrOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrOperator"):
                listener.exitOrOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrOperator"):
                return visitor.visitOrOperator(self)
            else:
                return visitor.visitChildren(self)

    def orOperator(self):
        localctx = LanguageParser.OrOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_orOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(LanguageParser.Or)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[9] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx: ExpressionContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 8)

        if predIndex == 1:
            return self.precpred(self._ctx, 7)

        if predIndex == 2:
            return self.precpred(self._ctx, 6)

        if predIndex == 3:
            return self.precpred(self._ctx, 5)

        if predIndex == 4:
            return self.precpred(self._ctx, 4)
